//시간제한 0.15초
//이 문제도 반복문을 통해 높이를 오르려고 할 경우,
//V의 범위가 최대 1,000,000,000이므로 시간초과가 발생한다.
//따라서, 몇일이 걸리는지를 수학적으로 식으로 구현하여야 한다.
 
//정상에 일단 다다르기만 하면 미끄러지지는 않으므로,
//최종적으로 가야하는 목표는 V가 아닌 V-A까지만 가면 다음날 아침에 A만큼 올라서 정상에 다다를 수 있다.
 
//그리고 V-A를 가는데에 걸리는 기간은 (V-A)/(A-B)이다.
//이때 (V-A) / (A-B)가 나머지가 0일 경우에는 (V-A) / (A-B) 일
//만큼 오르고, 마지막날 A만큼 오르면 되지만,
//(V-A) / (A-B)의 나머지가 0이 아닐 경우에는
//정상에 도달하기에 이동거리가 조금 모자라므로 1을 추가로 더해주면 된다.

#include <iostream>
using namespace std;
int main() {
    int a,b,v;
    cin >> a >> b >> v;
    int day = 1;
    day += (v-a)/(a-b);
    if((v-a)%(a-b) != 0) //이동거리 모자라므로 1추가
        day++;
    if(a >= v)
        cout << "1";
    else
        cout << day;
    return 0;
}
